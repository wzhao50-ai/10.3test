<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Cotton Candy</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #fce4ec;
            font-family: Arial, sans-serif;
        }

        .cotton-candy {
            width: 200px;
            height: 200px;
            background-color: #b3e5fc;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .stick {
            width: 10px;
            height: 100px;
            background-color: #ffccbc;
            position: absolute;
            bottom: -90px;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Shape classes */
        .cloud {
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%;
        }

        .cat {
            clip-path: polygon(50% 0%, 83% 12%, 100% 43%, 94% 78%, 68% 100%, 32% 100%, 6% 78%, 0% 43%, 17% 12%);
        }

        .key {
            clip-path: polygon(0% 40%, 20% 40%, 20% 60%, 40% 60%, 40% 40%, 100% 40%, 100% 60%, 40% 60%, 40% 80%, 20% 80%, 20% 60%, 0% 60%);
        }

        .heart {
            clip-path: path('M50,15 a25,25 0 0,1 50,25 a25,25 0 0,1 -50,50 a25,25 0 0,1 -50,-50 a25,25 0 0,1 50,-25');
        }

        .apple {
            clip-path: polygon(50% 0%, 80% 10%, 100% 35%, 100% 70%, 80% 90%, 50% 100%, 20% 90%, 0% 70%, 0% 35%, 20% 10%);
        }

        .instructions {
            margin-top: 20px;
            text-align: center;
            color: #666;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <div class="cotton-candy cloud">
        <div class="stick"></div>
    </div>
    <div class="instructions">
        Click: Change Color | Double Click: Change Shape | Hover: Grow & Wiggle
    </div>
    <script>
        // --- Cotton candy interactivity (unchanged behavior kept) ---
        const cottonCandy = document.querySelector('.cotton-candy');
        const colors = ['#b3e5fc', '#e1bee7', '#ffcdd2', '#c8e6c9', '#fff9c4', '#d1c4e9'];
        const shapes = ['cloud', 'cat', 'key', 'heart', 'apple'];
        let colorIndex = 0;
        let shapeIndex = 0;
        let isLarge = false;
        let wiggleInterval;

        cottonCandy.classList.add('cloud');

        cottonCandy.addEventListener('click', (e) => {
            if (e.detail === 1) {
                colorIndex = (colorIndex + 1) % colors.length;
                cottonCandy.style.backgroundColor = colors[colorIndex];
            }
        });

        cottonCandy.addEventListener('dblclick', () => {
            cottonCandy.classList.remove(shapes[shapeIndex]);
            shapeIndex = (shapeIndex + 1) % shapes.length;
            cottonCandy.classList.add(shapes[shapeIndex]);
        });

        cottonCandy.addEventListener('mouseover', () => {
            if (!isLarge) {
                cottonCandy.style.transform = 'scale(1.2)';
                isLarge = true;
            }
            let angle = 0;
            wiggleInterval = setInterval(() => {
                angle = (angle + 1) % 360;
                const wiggle = Math.sin(angle * Math.PI / 180) * 5;
                cottonCandy.style.transform = `scale(1.2) rotate(${wiggle}deg)`;
            }, 50);
        });

        cottonCandy.addEventListener('mouseout', () => {
            cottonCandy.style.transform = 'scale(1) rotate(0deg)';
            isLarge = false;
            clearInterval(wiggleInterval);
        });

        // --- Abstract pattern & symbolic myth generator ---
        // Create UI elements
        const canvasContainer = document.createElement('div');
        canvasContainer.style.marginTop = '40px';
        canvasContainer.style.textAlign = 'center';

        const canvas = document.createElement('canvas');
        canvas.width = 600;
        canvas.height = 400;
        canvas.style.border = '1px solid rgba(0,0,0,0.08)';
        canvas.style.borderRadius = '8px';
        canvas.style.boxShadow = '0 6px 18px rgba(0,0,0,0.08)';
        canvasContainer.appendChild(canvas);

        const controls = document.createElement('div');
        controls.style.marginTop = '12px';

        const randomBtn = document.createElement('button');
        randomBtn.textContent = 'Randomize Pattern';
        randomBtn.style.marginRight = '8px';

        const lockSymbolBtn = document.createElement('button');
        lockSymbolBtn.textContent = 'Toggle Symbol Overlay';
        lockSymbolBtn.style.marginRight = '8px';

        const downloadBtn = document.createElement('button');
        downloadBtn.textContent = 'Download PNG';

        controls.appendChild(randomBtn);
        controls.appendChild(lockSymbolBtn);
        controls.appendChild(downloadBtn);
        canvasContainer.appendChild(controls);

        document.body.appendChild(canvasContainer);

        const ctx = canvas.getContext('2d');
        let symbolOverlay = true;

        // Utility: random helpers
        function rand(min, max) { return Math.random() * (max - min) + min; }
        function pick(arr) { return arr[Math.floor(Math.random() * arr.length)]; }

        // Palettes and symbol set (symbolic myth shapes)
        const palettes = [
            ['#ffb3c6', '#ffd6a5', '#fef08a', '#c7f9cc', '#b3e5fc'],
            ['#e1bee7', '#c5cae9', '#b2ebf2', '#dcedc8', '#ffe0b2'],
            ['#d1c4e9', '#f8bbd0', '#ffcdd2', '#f0f4c3', '#bbdefb']
        ];

        // Basic symbol drawing (mythic glyphs) - simplified icons
        function drawSymbol(cx, cy, size, type, color) {
            ctx.save();
            ctx.translate(cx, cy);
            ctx.fillStyle = color;
            ctx.strokeStyle = 'rgba(0,0,0,0.08)';
            ctx.lineWidth = 2;
            if (type === 'eye') {
                ctx.beginPath();
                ctx.ellipse(0, 0, size * 1.2, size * 0.6, 0, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.3, 0, Math.PI * 2);
                ctx.fill();
            } else if (type === 'spiral') {
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = i * 0.8;
                    const r = (i / 6) * size;
                    const x = Math.cos(angle) * r;
                    const y = Math.sin(angle) * r;
                    if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
                }
                ctx.stroke();
            } else if (type === 'sigil') {
                ctx.beginPath();
                ctx.moveTo(-size * 0.6, -size * 0.6);
                ctx.lineTo(size * 0.6, size * 0.6);
                ctx.moveTo(size * 0.6, -size * 0.6);
                ctx.lineTo(-size * 0.6, size * 0.6);
                ctx.stroke();
            } else if (type === 'triangle') {
                ctx.beginPath();
                ctx.moveTo(0, -size);
                ctx.lineTo(size, size);
                ctx.lineTo(-size, size);
                ctx.closePath();
                ctx.fill();
            } else { // circle
                ctx.beginPath();
                ctx.arc(0, 0, size, 0, Math.PI * 2);
                ctx.fill();
            }
            ctx.restore();
        }

        // Abstract pattern generation: composition of blobs, strokes, and symbols
        function generatePattern() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            const palette = pick(palettes);
            // background wash
            ctx.fillStyle = pick(palette) + '33';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // draw random blobs
            for (let i = 0; i < 12; i++) {
                const x = rand(0, canvas.width);
                const y = rand(0, canvas.height);
                const w = rand(40, 160);
                const h = rand(30, 120);
                ctx.beginPath();
                ctx.ellipse(x, y, w, h, rand(0, Math.PI), 0, Math.PI * 2);
                ctx.fillStyle = pick(palette);
                ctx.globalAlpha = 0.75;
                ctx.fill();
            }
            ctx.globalAlpha = 1;

            // overlay strokes
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo(rand(0, canvas.width), rand(0, canvas.height));
                for (let j = 0; j < 6; j++) {
                    ctx.lineTo(rand(0, canvas.width), rand(0, canvas.height));
                }
                ctx.strokeStyle = pick(palette);
                ctx.globalAlpha = 0.15;
                ctx.lineWidth = rand(10, 30);
                ctx.stroke();
            }
            ctx.globalAlpha = 1;

            // place mythic symbols
            if (symbolOverlay) {
                const symbols = ['eye', 'spiral', 'sigil', 'triangle', 'circle'];
                for (let i = 0; i < 6; i++) {
                    const x = rand(60, canvas.width - 60);
                    const y = rand(60, canvas.height - 60);
                    const s = rand(14, 48);
                    const type = pick(symbols);
                    drawSymbol(x, y, s, type, pick(palette));
                }
            }
        }

        // initial draw
        generatePattern();

        randomBtn.addEventListener('click', generatePattern);
        lockSymbolBtn.addEventListener('click', () => {
            symbolOverlay = !symbolOverlay;
            lockSymbolBtn.textContent = symbolOverlay ? 'Toggle Symbol Overlay' : 'Symbol Overlay: Off';
            generatePattern();
        });

        downloadBtn.addEventListener('click', () => {
            const a = document.createElement('a');
            a.href = canvas.toDataURL('image/png');
            a.download = 'pattern.png';
            a.click();
        });
    </script>
</body>
</html>
